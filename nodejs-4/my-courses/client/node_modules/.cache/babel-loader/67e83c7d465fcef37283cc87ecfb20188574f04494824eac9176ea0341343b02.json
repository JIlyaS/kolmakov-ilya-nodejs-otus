{"ast":null,"code":"import { createStore as e, createEvent as r, is as o, createNode as t, withRegion as a, createEffect as i, sample as n, guard as f, forward as s, clearNode as u } from \"effector\";\nvar l = new Map(),\n  d = r();\nfunction p(p) {\n  return y => function (_ref) {\n    let {\n      adapter: p,\n      store: y,\n      source: k = y,\n      target: c = y,\n      clock: m = k,\n      done: v,\n      fail: g = d,\n      finally: h,\n      pickup: w,\n      key: x,\n      keyPrefix: P = \"\"\n    } = _ref;\n    if (!p) throw Error(\"Adapter is not defined\");\n    if (!k) throw Error(\"Store or source is not defined\");\n    if (!c) throw Error(\"Target is not defined\");\n    if (!x && k.shortName === k.id) throw Error(\"Key or name is not defined\");\n    if (k === c && !o.store(k)) throw Error(\"Source must be different from target\");\n    var E = x || k.shortName,\n      M = function (r, o) {\n        var t = l.get(r);\n        void 0 === t && (t = new Map(), l.set(r, t));\n        var a = t.get(o);\n        return void 0 !== a || (a = e(null, {\n          serialize: \"ignore\"\n        }), t.set(o, a)), a;\n      }(p.keyArea || p, P + E),\n      b = t(),\n      A = () => u(b),\n      D = e => _ref2 => {\n        let {\n          status: r,\n          params: o,\n          result: t,\n          error: a\n        } = _ref2;\n        return \"done\" === r ? {\n          status: r,\n          key: E,\n          keyPrefix: P,\n          operation: e,\n          value: \"get\" === e ? t : o\n        } : {\n          status: r,\n          key: E,\n          keyPrefix: P,\n          operation: e,\n          value: o,\n          error: a\n        };\n      };\n    return a(b, () => {\n      var e = i(),\n        o = i(),\n        t = r(),\n        a = t.filterMap(_ref3 => {\n          let {\n            status: e,\n            key: r,\n            keyPrefix: o,\n            operation: t,\n            value: a\n          } = _ref3;\n          return \"done\" === e ? {\n            key: r,\n            keyPrefix: o,\n            operation: t,\n            value: a\n          } : void 0;\n        }),\n        u = t.filterMap(_ref4 => {\n          let {\n            status: e,\n            key: r,\n            keyPrefix: o,\n            operation: t,\n            error: a,\n            value: i\n          } = _ref4;\n          return \"fail\" === e ? {\n            key: r,\n            keyPrefix: o,\n            operation: t,\n            error: a,\n            value: i\n          } : void 0;\n        }),\n        l = p(P + E, e);\n      e.use(l.get), o.use(l.set);\n      var d = r();\n      n({\n        source: k,\n        clock: m,\n        target: d\n      }), f({\n        source: n(M, d, (e, r) => [r, e]),\n        filter: _ref5 => {\n          let [e, r] = _ref5;\n          return e !== r;\n        },\n        target: o.prepend(_ref6 => {\n          let [e] = _ref6;\n          return e;\n        })\n      }), s({\n        from: [e.doneData, o],\n        to: M\n      }), s({\n        from: [e.doneData, M],\n        to: c\n      }), s({\n        from: [e.finally.map(D(\"get\")), o.finally.map(D(\"set\"))],\n        to: t\n      }), s({\n        from: u,\n        to: g\n      }), v && s({\n        from: a,\n        to: v\n      }), h && s({\n        from: t,\n        to: h\n      }), w ? s({\n        from: w,\n        to: e.prepend(() => {})\n      }) : e();\n    }), A.unsubscribe = A;\n  }({\n    ...p,\n    ...y\n  });\n}\nd.watch(e => console.error(e.error));\nvar y = p();\nexport { p as createPersist, y as persist };","map":{"version":3,"names":["l","Map","d","r","p","y","_ref","adapter","store","source","k","target","c","clock","m","done","v","fail","g","finally","h","pickup","w","key","x","keyPrefix","P","Error","shortName","id","o","E","M","t","get","set","a","e","serialize","keyArea","b","A","desist","u","D","_ref2","status","params","result","error","operation","value","i","filterMap","_ref3","_ref4","use","n","f","filter","_ref5","prepend","_ref6","s","from","doneData","to","map","unsubscribe","watch","console","createPersist","persist"],"sources":["/Users/ilakolmakov/kolmakov-ilya-nodejs-otus/nodejs-4/my-courses/client/node_modules/src/area.ts","/Users/ilakolmakov/kolmakov-ilya-nodejs-otus/nodejs-4/my-courses/client/node_modules/src/persist.ts","/Users/ilakolmakov/kolmakov-ilya-nodejs-otus/nodejs-4/my-courses/client/node_modules/src/index.ts"],"sourcesContent":["import type { Store } from 'effector'\nimport { createStore } from 'effector'\n\n/**\n * Keys areas / namespaces cache\n */\nconst areas = new Map<any, Map<string, Store<any>>>()\n\n/**\n * Get store, responsible for the key in key area / namespace\n */\nexport function getAreaStorage<State>(keyArea: any, key: string): Store<State> {\n  let area = areas.get(keyArea)\n  if (area === undefined) {\n    area = new Map()\n    areas.set(keyArea, area)\n  }\n\n  let store = area.get(key)\n  if (store !== undefined) {\n    return store\n  }\n\n  // @ts-expect-error due to old typings in import\n  store = createStore(null, { serialize: 'ignore' })\n  area.set(key, store)\n\n  return store\n}\n","import type { Subscription } from 'effector'\nimport type {\n  ConfigPersist,\n  ConfigSourceTarget,\n  ConfigStore,\n  Done,\n  Fail,\n  Finally,\n} from './types'\nimport {\n  clearNode,\n  createEffect,\n  createEvent,\n  createNode,\n  forward,\n  guard,\n  is,\n  sample,\n  withRegion,\n} from 'effector'\nimport { getAreaStorage } from './area'\n\n/**\n * Default sink for unhandled errors\n */\nconst sink = createEvent<Fail<any>>()\nsink.watch((payload) => console.error(payload.error))\n\n/**\n * Main `persist` function\n */\nexport function persist<State, Err = Error>({\n  adapter,\n  store,\n  source = store,\n  target = store,\n  clock = source,\n  done,\n  fail = sink,\n  finally: anyway,\n  pickup,\n  key: keyName,\n  keyPrefix = '',\n}: Partial<\n  ConfigPersist & ConfigStore<State, Err> & ConfigSourceTarget<State, Err>\n>): Subscription {\n  if (!adapter) {\n    throw Error('Adapter is not defined')\n  }\n  if (!source) {\n    throw Error('Store or source is not defined')\n  }\n  if (!target) {\n    throw Error('Target is not defined')\n  }\n  if (!keyName && source.shortName === (source as any).id) {\n    throw Error('Key or name is not defined')\n  }\n  if (source === target && !is.store(source)) {\n    throw Error('Source must be different from target')\n  }\n\n  const key = keyName || source.shortName\n  const storage = getAreaStorage<State>(\n    adapter.keyArea || adapter,\n    keyPrefix + key\n  )\n  const region = createNode()\n  const desist = () => clearNode(region)\n\n  const op =\n    (operation: 'get' | 'set') =>\n    ({ status, params, result, error }: any): any =>\n      status === 'done'\n        ? {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: operation === 'get' ? result : params,\n          }\n        : {\n            status,\n            key,\n            keyPrefix,\n            operation,\n            value: params,\n            error,\n          }\n\n  // create all auxiliary units and nodes within the region,\n  // to be able to remove them all at once on unsubscription\n  withRegion(region, () => {\n    const getFx = createEffect<void, State, Err>()\n    const setFx = createEffect<State, void, Err>()\n\n    const localAnyway = createEvent<Finally<State, Err>>()\n    const localDone = localAnyway.filterMap<Done<State>>(\n      ({ status, key, keyPrefix, operation, value }) =>\n        status === 'done' ? { key, keyPrefix, operation, value } : undefined\n    )\n    const localFail = localAnyway.filterMap<Fail<Err>>(\n      ({ status, key, keyPrefix, operation, error, value }: any) =>\n        status === 'fail'\n          ? { key, keyPrefix, operation, error, value }\n          : undefined\n    )\n\n    const value = adapter<State>(keyPrefix + key, getFx)\n    getFx.use(value.get)\n    setFx.use(value.set)\n\n    const trigger = createEvent<State>()\n    sample({\n      source,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      clock: clock!, // `clock` is always defined, as long as `source` is defined\n      target: trigger,\n    })\n\n    guard({\n      source: sample<State, State, [State, State]>(\n        storage,\n        trigger,\n        (current, proposed) => [proposed, current]\n      ),\n      filter: ([proposed, current]) => proposed !== current,\n      target: setFx.prepend<[State, State]>(([proposed]) => proposed),\n    })\n    forward({ from: [getFx.doneData, setFx], to: storage })\n    forward({ from: [getFx.doneData, storage], to: target })\n    forward({\n      from: [getFx.finally.map(op('get')), setFx.finally.map(op('set'))],\n      to: localAnyway,\n    })\n\n    forward({ from: localFail, to: fail })\n    if (done) forward({ from: localDone, to: done })\n    if (anyway) forward({ from: localAnyway, to: anyway })\n\n    if (pickup) {\n      // pick up value from storage ONLY on `pickup` update\n      forward({ from: pickup, to: getFx.prepend(() => undefined) })\n    } else {\n      // kick getter to pick up initial value from storage\n      getFx()\n    }\n  })\n\n  return (desist.unsubscribe = desist)\n}\n","import type { ConfigPersist, Persist } from './types'\nimport { persist as base } from './persist'\n\nexport type {\n  ConfigPersist,\n  ConfigSourceTarget,\n  ConfigStore,\n  Done,\n  Fail,\n  Finally,\n  Persist,\n  StorageAdapter,\n} from './types'\n\n/**\n * Creates custom `persist`\n */\nexport function createPersist(defaults?: ConfigPersist): Persist {\n  return (config) => base({ ...defaults, ...config })\n}\n\n/**\n * Default `persist`\n */\nexport const persist = createPersist()\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}